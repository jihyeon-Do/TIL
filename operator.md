## 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.

이때 연산의 대상을 피연산자라 한다.

##### 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.

피연산자와 연산자의 조합으로 이루어진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.

```js
5 * 4 // -> 20
// 산술 연산자

'My name is' + 'Lee' // -> My name is Lee
// 문자열 연결 연산자

color = 'red' // 'red'
// 할당 연산자

3 > 5 // false
// 비교 연산자

true && false // false
// 논리 연산자

typeof 'Hi' // string
// 타입 연산자
```

피연산자 : '값'

연산자 : '피연산자를 연산하여 새로운 값을 만든다'



### 1. 산술연산자

- 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다 (새로운 값 생성)

- 산술 연산이 불가능한 경우 NaN을 반환

- 산술연산자는 피연산자의 개수에 따라 이항 산술연산자와 단항 산술 연산자로 구분할 수 있다.



#### 1.1 이항 산술 연산자

- 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.

- 모든 이항 산술 연산자는 값을 변경하는 부수 효과가 없다. 
  다시말해 어떤 산술연산을 해도 피연산자의 값이 바뀌는 경우는 없다 => 언제나 새로운 값을 만든다.

#### 1.2. 단항 산술 연산자

- 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.(반환한다, 출력한다)
- 이항산술 연산자와는 달리 증가 / 감소 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.

| 단항 산술 연산자 | 의미                                                      | 부수 효과 |
| ---------------- | --------------------------------------------------------- | --------- |
| ++               | 증가                                                      | o         |
| --               | 감소                                                      | o         |
| +                | 어떠한 효과도 없다. 음수를 양수로 <br />반전하지도 않는다 | x         |
| -                | 양수를 음수로 음수를 양수로<br />반전한 값을 반환한다.    | x         |

##### 증가 / 감소 연산자

- 위치에 의미가 있다.
- 피연산자 앞에 위치한 전위 증가 / 감소 연산자는 먼저 피연산자의 값을 증가 / 감소시킨 후, 다른 연산을 
  수행한다.
- 피연산자 뒤에 위치한 후위 증가 / 감소 연산자는 먼저 다른 연산을 수행한 수 , 피연산자의 값을
  증가 / 감소 시킨다.

```js
var x = 5, result;

result = x++;
console.log(result, x); // 5 6 
// 선할당 후증가

result = ++x;
console.log(result, x); // 7 7
// 선증가 후할당

result = x--;
console.log(result, x); // 7 6
// 선할당 후감소

result = --x;
console.log(result, x); // 5 5
// 선감소 후할당
```

- `+` 단항 연산자는 피연산자에 어떠한 효과도 없다.
  - 그런데 숫자 타입이 아닌 피연산자 마저도 숫자타입으로 변환하여 반환할 수 있다.
  - 이때 피연산자를 변경하는 것은 아니고 숫자타입으로 변환한 값을 생성해서 반환한다.
  - 따라서 부수 효과는 없다.

```js
+10; // 10
+(-10); // -10
// 아무런 효과가 없다.

+'10'; // 10
// 문자열을 숫자로 타입 변환한다.

+true; // 1
// 불리언 값을 숫자로 타입 변환한다.

+false; // 0
// 불리언 값을 숫자로 타입 변환한다.

+'Hello'; // NaN
// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
```

- `-` 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.
- `+` 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 숫자타입으로 변환하여 반환한다.
  - 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 
  - 따라서 부수 효과는 없다.

```js
-(-10) // 10
// 부호를 반전한다.

-'10' // -10
// 문자열을 숫자로 타입 변환한다.

-true; // -1
// 불리언 값을 숫자로 타입 변환한다.

-'hello'; // NaN
// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
```



#### 1.3. 문자열 연결 연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

그외의 경우에는 덧셈 연산자로 동작한다.

```js
'1' + 2; // '12'
1 + '2'; // '12'
// 문자열 연결 연산자

1 + 2; // 3
// 산술 연산자

1 + true; // 2
// true는 1로 타입 변환된다.

1 + false; // 1
// false는 0으로 타입 변환된다.

1 + null; // 1
// null은 0으로 타입 변환된다.

+undefined; // NaN
1 + undefined; // NaN
// undefined는 숫자로 타입 변환되지 않는다.
```

##### 암묵적 타입 변환 또는 타입 강제 변환

- 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다.
- `1+true` 를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자타입인 1로 타입을 강제 변환한 후 연산을 수행한다.



### 2. 할당 연산자

할당 연산자 : 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

변수의 값이 변하는 부수 효과가 있다

| 할당 연산자 | 사례   | 동일 표현 | 부수 효과 |
| ----------- | ------ | --------- | --------- |
| =           | x = 5  | x = 5     | o         |
| +=          | x += 5 | x = x + 5 | o         |
| -=          | x -= 5 | x = x - 5 | o         |
| *=          | x *= 5 | x = x * 5 | o         |
| /=          | x /= 5 | x = x / 5 | o         |
| &           | x %= 5 | x = x % 5 | o         |

```js
var x;
x = 10;
console.log(x); // 10

x += 5;
console.log(x); // 15

x -= 5;
console.log(x); // 10

x *= 5;
console.log(x) // 50

x /= 5;
console.log(x) // 10

x %= 5;
console.log(x) // 0

var str = 'My name is ';
str += 'Lee';
console.log(str);
// My name is Lee

```

Q. 할당 연산은 표현식인 문일까?

나의 예상 : yes

```js
var x;

console.log(x = 10); // 10
// 할당문은 표현식인 문이다.
```

할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만
할당문은 값으로 평가되는 표현식인 문이다.

할당문은 평가되는 표현식이기 때문에 

할당문 `x = 10` 도 할당된 숫자 값 10으로 평가된다.

이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.

```js
var a, b, c;

a = b = c = 0;
console.log(a, b, c); // 0 0 0
// 연쇄할당. 오른쪽에서 왼쪽으로 진행
// c = 0 : 0으로 평가된다.
// b = 0 : 0으로 평가된다.
// a = 0 : 0으로 평가된다.
```



### 3. 비교 연산자

- 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

- 비교 연산자는 if 문이나 for문 같은 제어문의 조건식에서 주로 사용한다.



#### 3.1. 동등 / 일치 비교 연산자

동등비교 연산자

일치비교 연산자

| 비교연산자 | 의미        | 사례    | 설명                     | 부수 효과 |
| ---------- | ----------- | ------- | ------------------------ | --------- |
| ==         | 동등 비교   | x == y  | x와 y의 값이 같음        | x         |
| ===        | 일치 비교   | x === y | x와 y의 값과 타입이 같음 | x         |
| !=         | 부동등 비교 | x != y  | x와 y의 값이 다름        | x         |
| !==        | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | x         |

##### 동등비교연산자

- 좌항과 우항의 피연산자를 비교할때 암묵적 타입변환을 통해 타입을 일치시킨후 같은 값인지 비교
- 좌항과 우항의 피연산자 타입이 다르더라도 암묵적 타입변환후에 같은 값일 수 있다면  true

```js
5 == 5; // true
// 동등비교

5 == '5'; // true
// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
```

- 하지만 결과를 예측하기 어려워 부작용이 일어날수 있으므로 사용하지 않는 편이 좋다.

```js
'0' == ''; // false
0 == ''; // true
0 == '0' // true
false == 'false' // false
false == '0' // true
false == null; // false
false == undefined; // false
```

##### 일치 비교 연산자

- 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
- 타입변환을 하지않고 그대로 값을 비교한다.

```js
5 === 5; // true
// 일치 비교

5 === '5'; // false
// 암묵적 타입 변환을 하지 않고 값을 비교한다.
// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
```

- 그러나 일치 비교 연산자에서 주의할 것은 NaN이다.

```js
NaN === NaN; //false
// NaN은 자신과 일치하지 않는 유일한 값이다.
```

따라서 숫자가  NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다.

```js
isNaN(NaN); // true
isNaN(10); // false
isNaN(1 + undefined); // true
```

자바스크립트는 음의  0과 양의 0이 있다.

```js
0 === -0; // true
0 == -0; // true
// 양의0과 음의0의 비교, 일치비교 동등비교 모두 true 이다
```



##### Object.is 메소드

위에서 살펴본 바와 같이 동등 비교 연산자(==)와 일치 비교 연산자(===)는 +0 -0 동일하다고 평가한다. 또한 동일한 값이 NaN과 NaN을 비교하며 다른 값이라고 평가한다.

ES6에서 새롭게 도입된 Object.is메소드는 아래와 같이 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.

```js
-0 === +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

 

부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대개념이다.

```js
5 != 8; // true
5 != 5; // false
5 != '5' // false
// 부동등 비교

5 !== 8; // true
5 === 5; // false
5 !== '5' // true
```



#### 3.2. 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

| 대소 관계 비교 연산자 | 예제   | 설명                  | 부수 효과 |
| --------------------- | ------ | --------------------- | --------- |
| >                     | x > y  | x가 y보다 크다        | x         |
| <                     | x < y  | x가  y보다 작다       | x         |
| >=                    | x >= y | x가 y보다 같거나 크다 | x         |
| <=                    | x <= y | x가 y보다 같거나 작다 | x         |



### 4. 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

자바스크립트의 유일한 삼항 연산자이며 부수효과는 없다.

```
조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값
```

```js
var x = 2;

var result = x % 2 ? '홀수' : '짝수';
console.log(result);// 짝수
// 2 % 2 는 0이고 0은 false로 암묵적 타입 변환된다.
```

```js
var x = 2, result;

if (x % 2) result = '홀수';
else 	   result = '짝수';

console.log(result); // 짝수
```

if...else문을 사용해도 동일한 처리를 할 수 있으나,

if...else문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 는없다.

```js
var x = 10;

var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };// SyntaxError
// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
```

##### 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.

값처럼 다른 표현식의 일부가 될 수 있어 매우 유용

```js
var x = 10;

var result = x % 2 ? '홀수' : '짝수';
// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
console.log(result); // 짝수
```

if...else와 삼항연산자가 비슷하다.



### 5. 논리 연산자

논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.

| 논리 연산자 | 의미        | 부수 효과 |
| ----------- | ----------- | --------- |
| \|\|        | 논리합(OR)  | x         |
| &&          | 논리곱(AND) | x         |
| !           | 부정(NOT)   | x         |

```js
true || true; // true
true || false; // true
false || true; // true
false || false; // false
// 논리 연산자 중 논리합 연산자

true && true; // true
true && false; // false
false && true; // false
false && false; // false
// 논리 연산자 중 논리곱 연산자

!true; // false
!false; // true
// 논리 연산자 중 부정 연산자
```

- 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 
  만약 피연산자가 불리언값이 아니면 불리언 타입으로 암묵적으로 변환된다.

```js
!0 // true
!'Hello'; //false
// 암묵적 타입 변환
```

- 논리합 또는 논리곱 연산자 표현식의 평가 결과는 불리언값이 아닐수도있다. 
- 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중  어느 한쪽으로 평가된다.





### 6. 쉼표 연산자

쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 
마지막 피연산자의 평가결과를 반환한다.

```js
var x, y, z;

x = 1, y = 2, z = 3; // 3
```



### 7. 그룹 연산자

그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 

그룹연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다.

```js
/*1.*/ 10 * 2 + 3; // 23

/*2.*/ 10 * (2 + 3); // 50
// 그룹 연산자를 사용하여 우선 순위 조절
```

1. `10 * 2` 를 먼저 연산 후 `20 + 3`을 연산
2. 그룹 연산자로 감싼 표현식을 먼저 연산한다. `2 + 3`을 먼저 연산, 그 다음 `10 * 5` 를 연산



### 8. typeof 연산자

- 피연산자의 데이터 타입을 **문자열로** 반환한다.

- null을 반환하는 경우는 x

- 함수의 경우  function반환

- typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다.

```js
typeof '' // "string"
typeof 1 // "number"
typeof NaN // "number"
typeof true // "boolean"
typeof undefined // "undefined"
typeof Symbol() // "symbol"
typeof null // "object"
typeof [] // "object"
typeof {} // "object"
typeof new Date() // "object"
typeof /test/gi // "object"
typeof function (){} // "function"
```

#### 주의할점

1. 여기서 null 의 값을 연산해 보면 "null"이 아닌 "object"를 반환하는 것에 주의하자
   따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치연산자(===)를 사용하도록 하자

```js
var foo = null;

typeof foo === null; // false
foo === null; // true
```

2. 선언하지 않은 식별자를  연산했을 때 ReferenceError 발생하지 않고 `undefined`를 반환한다.

```js
typeof undeclared; // undefined
// 식별자 undeclared를 선언한 적이 없다.
```



### 지수 연산자

ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자들 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 
숫자 타입의 값을 반환한다.

```js
2 ** 2 ; // 4
2 ** 2.5; /// 5.65685424649238
2 ** 0; // 1
2 ** -2 // 0.25
```

지수 연산자가 도입되기 이전에는 Math.pow 메소드를 사용하였다.

```js
Math.pow(2,2); // 4
Math.pow(2, 2.5); // 5.65685424649238
Math.pow(2, 0); // 1
Math.pow(2, -2); // 0.25
```

지수연산자는 여러 개의 피연산자를 사용할 경우, Math.pow 메소드 보다 가독성이 좋다.

```js
2 ** 2 ** 2 // 16

Math.pow(Math.pow(2, 2), 2); // 16
```

음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다.

```js
-5 ** 2;
// syntaxError
(-5) ** 2; // 25
```

지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.

```js
var num = 5;
num **= 2; // 25
```

지수 연산자는 모든 이항 연산자보다 우선 순위가 높다.

```js
2 * 5 ** 2; // 50

// 5의 2승 = 25
// 25 * 2 실행
```



### 10. 그 외의 연산자

| 연산자     | 개요                                                         | 참조 |
| ---------- | ------------------------------------------------------------ | ---- |
| delete     | 프로퍼티 삭제                                                |      |
| new        | 생성자 함수를 호출할 때 사용                                 |      |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된<br />인스턴스인지 판별 |      |
| in         | 프로퍼티 존재 확인                                           |      |



### 11. 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다.

예를 들면 1 * 2는 다른코드에 어떠한 영향도 주지 않는다.

하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가있다.

부수 효과가 있는 연산자는 할당 (=), 증가/감소(++/-), delete 연산자 이다.

```js
var x;

x = 1;
console.log(x); // 1
// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.
// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.

x++;
console.log(x);// 2
// 증가(++) / 감소(--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.
// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.

var o = { a : 1 };

delete o.a;
console.log(o); // {}
// delete연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.
// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.
```


